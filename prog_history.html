<p>This article discusses the major developments in the <b>history of <a href="/wiki/Programming_language" title="Programming language">programming languages</a></b>.</p><h2>Early history</h2><p>During a nine-month period in 1842–1843, <a href="/wiki/Ada_Lovelace" title="Ada Lovelace">Ada Lovelace</a> translated the memoir of Italian mathematician, <a href="/wiki/Luigi_Menabrea" class="mw-redirect" title="Luigi Menabrea">Luigi Menabrea</a> about <a href="/wiki/Charles_Babbage" title="Charles Babbage">Charles Babbage</a>'s newest proposed machine, the <a href="/wiki/Analytical_engine" class="mw-redirect" title="Analytical engine">Analytical Engine</a>. With the article she appended a set of notes which specified in complete detail a method for calculating <a href="/wiki/Bernoulli_number" title="Bernoulli number">Bernoulli numbers</a> with the Analytical Engine, recognized by some historians as the world's first computer program.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup></p><p><a href="/wiki/Herman_Hollerith" title="Herman Hollerith">Herman Hollerith</a> realized that he could encode information on <a href="/wiki/Punched_card" title="Punched card">punch cards</a> when he observed that <a href="/wiki/Train" title="Train">train</a> <a href="/wiki/Conductor_(transportation)" class="mw-redirect" title="Conductor (transportation)">conductors</a> encode the appearance of the ticket holders on the train tickets using the position of punched holes on the tickets. Hollerith then encoded the 1890 American census data on punch cards.</p><p>The first computer codes were specialized for their applications. In the first decades of the 20th century, numerical calculations were based on decimal numbers. Eventually it was realized that logic could be represented with numbers, not only with words. For example, <a href="/wiki/Alonzo_Church" title="Alonzo Church">Alonzo Church</a> was able to express the <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a> in a formulaic way. The <a href="/wiki/Turing_machine" title="Turing machine">Turing machine</a> was an abstraction of the operation of a tape-marking machine, for example, in use at the telephone companies. Turing machines set the basis for storage of programs as data in the <a href="/wiki/Von_Neumann_architecture#Development_of_the_stored-program_concept" title="Von Neumann architecture">von Neumann architecture</a> of computers by representing a machine through a finite number. However, unlike the lambda calculus, Turing's code does not serve well as a basis for higher-level languages—its principal use is in rigorous analyses of <a href="/wiki/Computational_complexity_theory" title="Computational complexity theory">algorithmic complexity</a>.</p><p>Like many "firsts" in history, the first modern programming language is hard to identify. From the start, the restrictions of the hardware defined the language. Punch cards allowed 80 columns, but some of the columns had to be used for a sorting number on each card. FORTRAN included some keywords which were the same as English words, such as "IF", "GOTO" (go to) and "CONTINUE". The use of a <a href="/wiki/Drum_memory" title="Drum memory">magnetic drum</a> for memory meant that computer programs also had to be interleaved with the rotations of the drum. Thus the programs were more hardware-dependent.</p><p>To some people, what was the first modern programming language depends on how much power and human-readability is required before the status of "programming language" is granted. Jacquard looms and Charles Babbage's <a href="/wiki/Difference_engine" title="Difference engine">Difference Engine</a> both had simple, extremely limited languages for describing the actions that these machines should perform. One can even regard the punch holes on a <a href="/wiki/Player_piano" title="Player piano">player piano</a> scroll as a limited <a href="/wiki/Domain-specific_language" title="Domain-specific language">domain-specific language</a>, albeit not designed for human consumption.</p><h2>First programming languages</h2><p>In the 1940s, the first recognizably modern electrically powered computers were created. The limited speed and memory capacity forced programmers to write hand tuned <a href="/wiki/Assembly_language" title="Assembly language">assembly language</a> programs. It was eventually realized that programming in assembly language required a great deal of intellectual effort and was error-prone.</p><p>The first programming languages designed to communicate instructions to a computer were written in the 1950s. An early <a href="/wiki/High-level_programming_language" title="High-level programming language">high-level programming language</a> to be designed for a computer was <a href="/wiki/Plankalk%C3%BCl" title="Plankalkül">Plankalkül</a>, developed by the Germans for <a href="/wiki/Z3_(computer)" title="Z3 (computer)">Z3</a> by <a href="/wiki/Konrad_Zuse" title="Konrad Zuse">Konrad Zuse</a> between 1943 and 1945. However, it was not implemented until 1998 and 2000.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2">[2]</a></sup></p><p><a href="/wiki/John_Mauchly" title="John Mauchly">John Mauchly</a>'s <a href="/wiki/Short_Code_(computer_language)" title="Short Code (computer language)">Short Code</a>, proposed in 1949, was one of the first high-level languages ever developed for an <a href="/wiki/Electronic_computer" class="mw-redirect" title="Electronic computer">electronic computer</a>.<sup id="cite_ref-Sebesta_3-0" class="reference"><a href="#cite_note-Sebesta-3">[3]</a></sup> Unlike <a href="/wiki/Machine_code" title="Machine code">machine code</a>, Short Code statements represented mathematical expressions in understandable form. However, the program had to be translated into <a href="/wiki/Machine_code" title="Machine code">machine code</a> every time it ran, making the process much slower than running the equivalent machine code.</p><p>At the <a href="/wiki/University_of_Manchester" title="University of Manchester">University of Manchester</a>, <a href="/wiki/Alick_Glennie" title="Alick Glennie">Alick Glennie</a> developed <a href="/wiki/Autocode" title="Autocode">Autocode</a> in the early 1950s. A <a href="/wiki/High-level_programming_language" title="High-level programming language">programming language</a>, it used a <a href="/wiki/Compiler" title="Compiler">compiler</a> to automatically convert the language into machine code. The first code and compiler was developed in 1952 for the <a href="/wiki/Manchester_Mark_1" title="Manchester Mark 1">Mark 1</a> computer at the University of Manchester and is considered to be the first <a href="/wiki/Compiler" title="Compiler">compiled</a> high-level programming language.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[4]</a></sup><sup id="cite_ref-5" class="reference"><a href="#cite_note-5">[5]</a></sup></p><p>The second autocode was developed for the Mark 1 by <a href="/wiki/Tony_Brooker" title="Tony Brooker">R. A. Brooker</a> in 1954 and was called the "Mark 1 Autocode". Brooker also developed an autocode for the <a href="/wiki/Ferranti_Mercury" title="Ferranti Mercury">Ferranti Mercury</a> in the 1950s in conjunction with the University of Manchester. The version for the <a href="/wiki/EDSAC" class="mw-redirect" title="EDSAC">EDSAC</a> 2 was devised by <a href="/w/index.php?title=D._F._Hartley&amp;action=edit&amp;redlink=1" class="new" title="D. F. Hartley (page does not exist)">D. F. Hartley</a> of <a href="/wiki/University_of_Cambridge_Mathematical_Laboratory" class="mw-redirect" title="University of Cambridge Mathematical Laboratory">University of Cambridge Mathematical Laboratory</a> in 1961. Known as EDSAC 2 Autocode, it was a straight development from Mercury Autocode adapted for local circumstances, and was noted for its object code optimisation and source-language diagnostics which were advanced for the time. A contemporary but separate thread of development, <a href="/wiki/Atlas_Autocode" title="Atlas Autocode">Atlas Autocode</a> was developed for the University of Manchester <a href="/wiki/Atlas_Computer_(Manchester)" class="mw-redirect" title="Atlas Computer (Manchester)">Atlas 1</a> machine.</p><p>In 1954, language <a href="/wiki/FORTRAN" class="mw-redirect" title="FORTRAN">FORTRAN</a> was invented at IBM by <a href="/wiki/John_Backus" title="John Backus">John Backus</a>; it was the first widely used <a href="/wiki/High-level_language" class="mw-redirect" title="High-level language">high level general purpose programming language</a> to have a functional implementation, as opposed to just a design on paper.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6">[6]</a></sup><sup id="cite_ref-7" class="reference"><a href="#cite_note-7">[7]</a></sup> It is still popular language for <a href="/wiki/High-performance_computing" class="mw-redirect" title="High-performance computing">high-performance computing</a><sup id="cite_ref-hpc_8-0" class="reference"><a href="#cite_note-hpc-8">[8]</a></sup> and is used for programs that benchmark and rank the world's <a href="/wiki/TOP500" title="TOP500">fastest supercomputers</a>.<sup id="cite_ref-9" class="reference"><a href="#cite_note-9">[9]</a></sup></p><p>Another early programming language was devised by <a href="/wiki/Grace_Hopper" title="Grace Hopper">Grace Hopper</a> in the US, called <a href="/wiki/FLOW-MATIC" title="FLOW-MATIC">FLOW-MATIC</a>. It was developed for the <a href="/wiki/UNIVAC_I" title="UNIVAC I">UNIVAC I</a> at <a href="/wiki/Remington_Rand" title="Remington Rand">Remington Rand</a> during the period from 1955 until 1959. Hopper found that business data processing customers were uncomfortable with mathematical notation, and in early 1955, she and her team wrote a specification for an <a href="/wiki/English_language" title="English language">English</a> programming language and implemented a prototype.<sup id="cite_ref-10" class="reference"><a href="#cite_note-10">[10]</a></sup> The FLOW-MATIC compiler became publicly available in early 1958 and was substantially complete in 1959.<sup id="cite_ref-11" class="reference"><a href="#cite_note-11">[11]</a></sup> Flow-Matic was a major influence in the design of <a href="/wiki/COBOL" title="COBOL">COBOL</a>, since only it and its direct descendent <a href="/wiki/AIMACO" class="mw-redirect" title="AIMACO">AIMACO</a> were in actual use at the time.<sup id="cite_ref-12" class="reference"><a href="#cite_note-12">[12]</a></sup></p><p>Other languages still in use today include <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">LISP</a> (1958), invented by <a href="/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy</a> and <a href="/wiki/COBOL" title="COBOL">COBOL</a> (1959), created by the Short Range Committee. Another milestone in the late 1950s was the publication, by a committee of American and European computer scientists, of "a new language for algorithms"; the <i><a href="/wiki/ALGOL" title="ALGOL">ALGOL</a> 60 Report</i> (the "<b>ALGO</b>rithmic <b>L</b>anguage"). This report consolidated many ideas circulating at the time and featured three key language innovations:</p><p>Another innovation, related to this, was in how the language was described:</p><p>Algol 60 was particularly influential in the design of later languages, some of which soon became more popular. The <a href="/wiki/Burroughs_large_systems" title="Burroughs large systems">Burroughs large systems</a> were designed to be programmed in an extended subset of Algol.</p><p>Algol's key ideas were continued, producing <a href="/wiki/ALGOL_68" title="ALGOL 68">ALGOL 68</a>:</p><p>Algol 68's many little-used language features (for example, concurrent and parallel blocks) and its complex system of syntactic shortcuts and automatic type coercions made it unpopular with implementers and gained it a reputation of being <i>difficult</i>. <a href="/wiki/Niklaus_Wirth" title="Niklaus Wirth">Niklaus Wirth</a> actually walked out of the design committee to create the simpler <a href="/wiki/Pascal_(programming_language)" title="Pascal (programming language)">Pascal</a> language.</p><p>Some notable languages that were developed in this period include:</p><h2>Establishing fundamental paradigms</h2><p>The period from the late 1960s to the late 1970s brought a major flowering of programming languages. Most of the major language paradigms now in use were invented in this period:</p><p>Each of these languages spawned an entire family of descendants, and most modern languages count at least one of them in their ancestry.</p><p>The 1960s and 1970s also saw considerable debate over the merits of "<a href="/wiki/Structured_programming" title="Structured programming">structured programming</a>", which essentially meant programming without the use of <a href="/wiki/Goto" title="Goto">Goto</a>. This debate was closely related to language design: some languages did not include GOTO, which forced structured programming on the programmer. Although the debate raged hotly at the time, nearly all programmers now agree that, even in languages that provide GOTO, it is bad <a href="/wiki/Programming_style" title="Programming style">programming style</a> to use it except in rare circumstances. As a result, later generations of language designers have found the structured programming debate tedious and even bewildering.</p><p>To provide even faster compile times, some languages were structured for "<a href="/wiki/One-pass_compiler" title="One-pass compiler">one-pass compilers</a>" which expect subordinate routines to be defined first, as with <a href="/wiki/Pascal_(programming_language)" title="Pascal (programming language)">Pascal</a>, where the main routine, or driver function, is the final section of the program listing.</p><p>Some notable languages that were developed in this period include:</p><h2>1980s: consolidation, modules, performance</h2><p>The 1980s were years of relative consolidation in <a href="/wiki/Imperative_language" class="mw-redirect" title="Imperative language">imperative languages</a>. Rather than inventing new paradigms, all of these movements elaborated upon the ideas invented in the previous decade. <a href="/wiki/C%2B%2B" title="C++">C++</a> combined object-oriented and systems programming. The United States government standardized <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a>, a systems programming language intended for use by defense contractors. In Japan and elsewhere, vast sums were spent investigating so-called <a href="/wiki/Fifth-generation_programming_language" title="Fifth-generation programming language">fifth-generation programming languages</a> that incorporated logic programming constructs. The functional languages community moved to standardize ML and Lisp. Research in <a href="/wiki/Miranda_(programming_language)" title="Miranda (programming language)">Miranda</a>, a functional language with <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy evaluation</a>, began to take hold in this decade.</p><p>One important new trend in language design was an increased focus on programming for large-scale systems through the use of <i>modules</i>, or large-scale organizational units of code. <a href="/wiki/Modula" title="Modula">Modula</a>, Ada, and ML all developed notable module systems in the 1980s. Module systems were often wedded to <a href="/wiki/Generic_programming" title="Generic programming">generic programming</a> constructs---generics being, in essence, parametrized modules (see also <a href="/wiki/Polymorphism_in_object-oriented_programming" class="mw-redirect" title="Polymorphism in object-oriented programming">polymorphism in object-oriented programming</a>).</p><p>Although major new paradigms for imperative programming languages did not appear, many researchers expanded on the ideas of prior languages and adapted them to new contexts. For example, the languages of the <a href="/wiki/Argus_(computer_system)" class="mw-redirect" title="Argus (computer system)">Argus</a> and <a href="/w/index.php?title=Emerald_(computer_system)&amp;action=edit&amp;redlink=1" class="new" title="Emerald (computer system) (page does not exist)">Emerald</a> systems adapted object-oriented programming to <a href="/wiki/Distributed_computing" title="Distributed computing">distributed systems</a>.</p><p>The 1980s also brought advances in programming language implementation. The <a href="/wiki/Reduced_instruction_set_computer" class="mw-redirect" title="Reduced instruction set computer">RISC</a> movement in <a href="/wiki/Computer_architecture" title="Computer architecture">computer architecture</a> postulated that hardware should be designed for <a href="/wiki/Compiler" title="Compiler">compilers</a> rather than for human assembly programmers. Aided by <a href="/wiki/Central_processing_unit" title="Central processing unit">processor</a> speed improvements that enabled increasingly aggressive compilation techniques, the RISC movement sparked greater interest in compilation technology for high-level languages.</p><p>Language technology continued along these lines well into the 1990s.</p><p>Some notable languages that were developed in this period include:</p><h2>1990s: the Internet age</h2><p>The rapid growth of the Internet in the mid-1990s was the next major historic event in programming languages. By opening up a radically new platform for computer systems, the Internet created an opportunity for new languages to be adopted. In particular, the JavaScript programming language rose to popularity because of its early integration with the Netscape Navigator web browser. Various other scripting languages achieved widespread use in developing customized applications for web servers such as PHP. The 1990s saw no fundamental novelty in <a href="/wiki/Imperative_language" class="mw-redirect" title="Imperative language">imperative languages</a>, but much recombination and maturation of old ideas. This era began the spread of <a href="/wiki/Functional_language" class="mw-redirect" title="Functional language">functional languages</a>. A big driving philosophy was programmer productivity. Many "rapid application development" (RAD) languages emerged, which usually came with an <a href="/wiki/Integrated_development_environment" title="Integrated development environment">IDE</a>, <a href="/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">garbage collection</a>, and were descendants of older languages. All such languages were <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented</a>. These included <a href="/wiki/Object_Pascal" title="Object Pascal">Object Pascal</a>, <a href="/wiki/Visual_Basic" title="Visual Basic">Visual Basic</a>, and <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>. Java in particular received much attention. More radical and innovative than the RAD languages were the new <a href="/wiki/Scripting_language" title="Scripting language">scripting languages</a>. These did not directly descend from other languages and featured new syntaxes and more liberal incorporation of features. Many consider these scripting languages to be more productive than even the RAD languages, but often because of choices that make small programs simpler but large programs more difficult to write and maintain.<sup class="noprint Inline-Template Template-Fact" style="white-space:nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (June 2009)">citation needed</span></a></i>]</sup> Nevertheless, scripting languages came to be the most prominent ones used in connection with the Web.</p><p>Some notable languages that were developed in this period include:</p><h2>Current trends</h2><p>Programming language evolution continues, in both industry and research. Some of the recent trends have included:</p><p>Some notable languages developed during this period include:</p><h2>Prominent people</h2><p>Some key people who helped develop programming languages:</p><h2>See also</h2><h2>References</h2><h2>Further reading</h2><h2>External links</h2>